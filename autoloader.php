<?php
//define default json file name who contains all the PHP files inside it.
define('AUTOLOAD_CONFIG_PHP', 'autoloader_config.php');

class autoloader
{

    static $instance = false;

    public static function instance()
    {
        if (self::$instance === false) {
            $instance = new self();
        }

        /** @var autoloader $instance */
        return $instance;
    }


    /**
     * Register autoloader.
     *
     * @param $directoryLevel
     * @param bool $debugMode will be try for new php files added in developing time.
     * @param string $fileExtension specific file Extension
     * @return spl_registrar|null
     */
    public function register($directoryLevel, $debugMode = false, $fileExtension = ".php")
    {
        if ($directoryLevel != null) {
            return new spl_registrar($this, $directoryLevel, $debugMode, $fileExtension);
        }

        return null;
    }

    /**
     * @param $dir_level : directory level is for file searching
     * @param $file_extension : our specific extension for files Default is .php
     */
    private function export_php_files($dir_level, $file_extension)
    {

        $file_paths = array();

        /**Get all files and directories using recursive iterator.*/
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($dir_level, RecursiveDirectoryIterator::SKIP_DOTS),
            RecursiveIteratorIterator::LEAVES_ONLY
        );

        /**Add all of iterated files in array */
        while ($iterator->valid()) {

            $path = strval($iterator->current());

            if (stripos(pathinfo($path, PATHINFO_BASENAME), $file_extension)) {
                $file_paths[] = str_replace($dir_level, '', $path);
            }
            //while have next maybe throw an exception.
            try {
                $iterator->next();
            } catch (Exception $ignored) {
                var_dump($ignored);
                break;
            }
        }
        $this->write_config($dir_level, $file_paths);
    }

    private function write_config($dir_level, $file_paths)
    {

        sort($file_paths, SORT_STRING);

        $fs = fopen( $dir_level . DIRECTORY_SEPARATOR . AUTOLOAD_CONFIG_PHP, "w" );
        if (!is_resource($fs)) {
            return false;
        }
        fwrite($fs, '<?php 
   
/**
 * ' . AUTOLOAD_CONFIG_PHP . ' @generated by Autoloader
 * Class autoloader_config_md5(directory level)
 */
class autoloader_config_' . md5($dir_level) . '    
{

    public static function get_files()
    {
        //sorted files in this directory level
        return [
             ' . time() . ',
            "' . implode('",' . PHP_EOL . '            "', $file_paths) . '"
        ];
    }

    public static function in_files($file_name)
    {
        $files = self::get_files();

        // starting a binary search
        $left = 0;
        $right = count($files) - 1;

        while ($left <= $right) {
            $midpoint = $left + intval(($right - $left) / 2);

            if (strnatcasecmp($files[$midpoint], $file_name) < 0) {
                $left = $midpoint + 1;
            } elseif (strnatcasecmp($files[$midpoint], $file_name) > 0) {
                $right = $midpoint - 1;
            } else {
                return $files[$midpoint];
            }
        }

        return false;
    }
}');

        fclose($fs);

        return true;
    }


    /**
     * @param $dir_level
     * @param $class_file_name : name of the class that was taken from @spl_autoload_register plus .php extension
     * @param $config_file
     * @return bool Succeeding end of work
     */
    private function include_matching_files($dir_level, $config_file, $class_file_name)
    {
        $inc_is_done = false;

        if (is_file($config_file) && is_readable($config_file)) {

            $result = call_user_func('autoloader_config_' . md5($dir_level) . '::in_files', $class_file_name);
            if ($result) {
                /** @noinspection PhpIncludeInspection */
                require_once $dir_level . $result;
                $inc_is_done = true;
            }
        }

        return $inc_is_done;
    }

    /**
     * @param $dir_level : directory level is for file searching
     * @param $class_name : name of the class that was taken from @spl_autoload_register
     * @param bool $try_for_new_files : Try again to include new files, that this feature is @true in development mode
     * it will renew including file each time after every 10 seconds @param $file_extension
     *
     * @return bool : Succeeding end of work
     * @see $files_refresh_time.
     */
    public function request_system_files($dir_level, $class_name, $try_for_new_files, $file_extension)
    {
        //Applying PSR-4 standard for including system files :
        $php_files_config = $dir_level . DIRECTORY_SEPARATOR . AUTOLOAD_CONFIG_PHP;
        $class_file_name = DIRECTORY_SEPARATOR . str_replace('\\', DIRECTORY_SEPARATOR, $class_name) . $file_extension;
        $files_refresh_time = 10;

        /**Exporting required php files.*/
        if (!is_file($php_files_config)) {
            $this->export_php_files($dir_level, $file_extension);
        }

        /** @noinspection PhpIncludeInspection */
        require_once $php_files_config;

        $found = $this->include_matching_files($dir_level, $php_files_config, $class_file_name);

        if (!$found && $try_for_new_files) {
            $updated_at = call_user_func('autoloader_config_' . md5($dir_level) . '::get_files')[0];
            if ((time() - intval($updated_at)) < $files_refresh_time) {
                $this->export_php_files($dir_level, $file_extension);
                $found = $this->include_matching_files($dir_level, $php_files_config, $class_file_name);
            }
        }

        return $found;
    }

    /**
     * Make constructor private, so nobody can call "new Class".
     */
    private function __construct()
    {
    }

    /**
     * Make clone magic method private, so nobody can clone instance.
     */
    private function __clone()
    {
    }

    /**
     * Make sleep magic method private, so nobody can serialize instance.
     * @noinspection PhpUnusedPrivateMethodInspection
     */
    private function __sleep()
    {
    }

    /**
     * Make wakeup magic method private, so nobody can unserialize instance.
     * @noinspection PhpUnusedPrivateMethodInspection
     */
    private function __wakeup()
    {
    }

}

/**
 * @spl_registrar this object is a registrar for spl_autoload_register
 * with @autoloader system
 */
class spl_registrar
{

    /**
     * @var autoloader
     */
    private $autoloader = null;
    /**
     * @var string registration level
     */
    private $directoryLevel = null;
    /**
     * @var string $file_extension is .php constant or a custom file extension
     */
    private $file_extension;
    /**
     * @var bool is on debug mode or not, indicates regenerate config when file not found
     */
    private $debug;

    function __construct($autoloader, $directoryLevel, $debugMode, $fileExtension)
    {
        $this->autoloader = $autoloader;
        $this->debug = $debugMode;
        $this->directoryLevel = $directoryLevel;
        $this->file_extension = $fileExtension;

        try {
            spl_autoload_register(array($this, 'load'), true, false);
        } catch (Exception $e) {
            var_dump($e);
            die;
        }

    }

    public function unregister()
    {
        spl_autoload_unregister(array($this, 'load'));
    }

    protected function load($className)
    {

        if (is_null($this->autoloader) || is_null($this->directoryLevel)) {
            return false;
        }

        return $this->autoloader->request_system_files(
            $this->directoryLevel,
            $className,
            $this->debug,
            $this->file_extension
        );
    }

}

